{
  "version": 3,
  "sources": ["../../../src/lib/mitsubishi/mitsubishiApi.ts"],
  "sourcesContent": ["// src/mitsubishi/mitsubishiApi.ts\r\nimport type { AxiosInstance } from \"axios\";\r\nimport axios from \"axios\";\r\nimport * as crypto from \"crypto\";\r\nimport { KEY_SIZE, STATIC_KEY } from \"./types\";\r\nimport { padIso7816, unpadIso7816 } from \"./utils\";\r\n\r\nexport class MitsubishiAPI {\r\n\tprivate adapter: ioBroker.Adapter;\r\n\tprivate deviceHostPort: string;\r\n\tprivate encryptionKey: Buffer;\r\n\tprivate http: AxiosInstance;\r\n\r\n\tconstructor(deviceHostPort: string, adapter: ioBroker.Adapter, encryptionKey: string | Buffer = STATIC_KEY) {\r\n\t\tthis.deviceHostPort = deviceHostPort;\r\n\t\tthis.adapter = adapter;\r\n\t\tif (typeof encryptionKey === \"string\") {\r\n\t\t\tencryptionKey = Buffer.from(encryptionKey, \"utf8\");\r\n\t\t}\r\n\t\tif (encryptionKey.length < KEY_SIZE) {\r\n\t\t\tencryptionKey = Buffer.concat([encryptionKey, Buffer.alloc(KEY_SIZE - encryptionKey.length, 0x00)]);\r\n\t\t}\r\n\t\tthis.encryptionKey = encryptionKey.subarray(0, KEY_SIZE);\r\n\r\n\t\tthis.http = axios.create({\r\n\t\t\ttimeout: 2000,\r\n\t\t\theaders: {\r\n\t\t\t\t\"User-Agent\":\r\n\t\t\t\t\t\"KirigamineRemote/5.1.0 (jp.co.MitsubishiElectric.KirigamineRemote; build:3; iOS 17.5.1) Alamofire/5.9.1\",\r\n\t\t\t},\r\n\t\t\t// do not automatically throw for non-2xx; we will call resp.status/raise manually\r\n\t\t\tvalidateStatus: () => true,\r\n\t\t});\r\n\t}\r\n\r\n\tgetCryptoKey(): Buffer {\r\n\t\treturn this.encryptionKey;\r\n\t}\r\n\r\n\tgetDeviceHostPort(): string {\r\n\t\treturn this.deviceHostPort;\r\n\t}\r\n\r\n\t/**\r\n\t * Encrypt payload using AES-CBC with ISO7816-4 padding\r\n\t * Returns base64(iv + ciphertext)\r\n\t */\r\n\tencryptPayload(payload: string, iv?: Buffer): string {\r\n\t\tif (!iv) {\r\n\t\t\tiv = crypto.randomBytes(KEY_SIZE);\r\n\t\t}\r\n\t\tconst cipher = crypto.createCipheriv(\"aes-128-cbc\", this.encryptionKey, iv);\r\n\t\tcipher.setAutoPadding(false);\r\n\r\n\t\tconst payloadBytes = Buffer.from(payload, \"utf8\");\r\n\t\tconst padded = padIso7816(payloadBytes, KEY_SIZE);\r\n\r\n\t\tconst encrypted = Buffer.concat([cipher.update(padded), cipher.final()]);\r\n\r\n\t\tconst combined = Buffer.concat([iv, encrypted]);\r\n\t\treturn combined.toString(\"base64\");\r\n\t}\r\n\r\n\t/**\r\n\t * Decrypt base64(iv + ciphertext) using AES-CBC + ISO7816 unpad fallback.\r\n\t * Try iso7816 unpad; on failure strip trailing \\x00;\r\n\t * then try to decode UTF-8; on UnicodeDecodeError search for closing tags and fallback to ignore errors.\r\n\t */\r\n\tdecryptPayload(payload_b64: string): string {\r\n\t\t// base64 -> bytes\r\n\t\tconst encrypted = Buffer.from(payload_b64, \"base64\"); // may throw\r\n\r\n\t\t// Extract IV and encrypted_data\r\n\t\tconst iv = encrypted.subarray(0, KEY_SIZE);\r\n\t\tconst encrypted_data = encrypted.subarray(KEY_SIZE);\r\n\r\n\t\t// AES-CBC decrypt\r\n\t\tconst decipher = crypto.createDecipheriv(\"aes-128-cbc\", this.encryptionKey, iv);\r\n\t\tdecipher.setAutoPadding(false);\r\n\t\tlet decrypted: Buffer;\r\n\t\ttry {\r\n\t\t\tdecrypted = Buffer.concat([decipher.update(encrypted_data), decipher.final()]);\r\n\t\t} catch (e) {\r\n\t\t\t// Propagate error (will be caught higher-level)\r\n\t\t\tthrow new Error(`Decryption failed: ${(e as Error).message}`);\r\n\t\t}\r\n\r\n\t\t// Try ISO7816 unpad\r\n\t\tlet decrypted_clean: Buffer;\r\n\t\ttry {\r\n\t\t\tdecrypted_clean = unpadIso7816(decrypted);\r\n\t\t} catch {\r\n\t\t\t// fallback: remove trailing 0x00\r\n\t\t\tlet end = decrypted.length;\r\n\t\t\twhile (end > 0 && decrypted[end - 1] === 0x00) {\r\n\t\t\t\tend--;\r\n\t\t\t}\r\n\t\t\tdecrypted_clean = decrypted.subarray(0, end);\r\n\t\t}\r\n\r\n\t\t// Try to decode as UTF-8\r\n\t\ttry {\r\n\t\t\tconst result = decrypted_clean.toString(\"utf8\");\r\n\t\t\treturn result;\r\n\t\t} catch {\r\n\t\t\t// Node's Buffer.toString won't throw UnicodeDecodeError; but we'll follow fallback logic.\r\n\t\t\t// Attempt to find closing tags in raw bytes, then decode slice.\r\n\t\t}\r\n\r\n\t\t// Try to find closing XML tags\r\n\t\tconst xml_end_patterns = [Buffer.from(\"</LSV>\"), Buffer.from(\"</CSV>\"), Buffer.from(\"</ESV>\")];\r\n\t\tfor (const pattern of xml_end_patterns) {\r\n\t\t\tconst pos = decrypted_clean.indexOf(pattern);\r\n\t\t\tif (pos !== -1) {\r\n\t\t\t\tconst end_pos = pos + pattern.length;\r\n\t\t\t\tconst truncated = decrypted_clean.subarray(0, end_pos);\r\n\t\t\t\ttry {\r\n\t\t\t\t\treturn truncated.toString(\"utf8\");\r\n\t\t\t\t} catch {\r\n\t\t\t\t\t// continue\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Last resort: decode ignoring errors (in Node Buffer.toString does not have errors='ignore' param,\r\n\t\t// but replacing invalid sequences is default behaviour; to mimic 'ignore' we can remove replacement characters)\r\n\t\t// We'll return decoded string (replacement characters may appear).\r\n\t\tconst fallback_result = decrypted_clean.toString(\"utf8\");\r\n\t\treturn fallback_result;\r\n\t}\r\n\r\n\t/**\r\n\t * Make HTTP request to /smart endpoint.\r\n\t * Encrypt payload, wrap in <ESV>..</ESV>, POST, parse response, decrypt.\r\n\t */\r\n\tasync makeRequest(payload_xml: string): Promise<string> {\r\n\t\t// Encrypt\r\n\t\tconst encrypted_payload = this.encryptPayload(payload_xml);\r\n\r\n\t\t// Build request body (exact same string shape)\r\n\t\tconst request_body = `<?xml version=\"1.0\" encoding=\"UTF-8\"?><ESV>${encrypted_payload}</ESV>`;\r\n\r\n\t\tconst headers = {\r\n\t\t\tHost: `${this.deviceHostPort}`,\r\n\t\t\t\"Content-Type\": \"text/plain;chrset=UTF-8\",\r\n\t\t\tConnection: \"keep-alive\",\r\n\t\t\t\"Proxy-Connection\": \"keep-alive\",\r\n\t\t\tAccept: \"*/*\",\r\n\t\t\t\"User-Agent\":\r\n\t\t\t\t\"KirigamineRemote/5.1.0 (jp.co.MitsubishiElectric.KirigamineRemote; build:3; iOS 17.5.1) Alamofire/5.9.1\",\r\n\t\t\t\"Accept-Language\": \"zh-Hant-JP;q=1.0, ja-JP;q=0.9\",\r\n\t\t};\r\n\r\n\t\tconst url = `http://${this.deviceHostPort}/smart`;\r\n\r\n\t\t// retry logic: total=4, backoff_factor=1 (attempts 0..4)\r\n\t\tconst maxRetries = 4;\r\n\t\tlet lastErr: any = null;\r\n\t\tfor (let attempt = 0; attempt <= maxRetries; attempt++) {\r\n\t\t\ttry {\r\n\t\t\t\tconst resp = await this.http.post(url, request_body, { headers, timeout: 2000 });\r\n\t\t\t\tthis.raiseForStatus(resp);\r\n\r\n\t\t\t\t// Parse XML root and get root.text like ElementTree.fromstring(...).text\r\n\t\t\t\t// Here extract inner text between the outermost tag, e.g. <ESV>...</ESV>\r\n\t\t\t\tconst m = String(resp.data).match(/<ESV>\\s*([^<]+)\\s*<\\/ESV>/i);\r\n\t\t\t\tconst encrypted_response = m?.[1];\r\n\r\n\t\t\t\tif (encrypted_response) {\r\n\t\t\t\t\tif (encrypted_response.length % 4 !== 0) {\r\n\t\t\t\t\t\tthis.adapter.log.error(`Invalid base64 length: ${encrypted_response.length}`);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tconst decrypted = this.decryptPayload(encrypted_response);\r\n\t\t\t\t\treturn decrypted;\r\n\t\t\t\t}\r\n\t\t\t\tthrow new Error(\"Could not find any text in response\");\r\n\t\t\t} catch (err) {\r\n\t\t\t\tlastErr = err;\r\n\t\t\t\tif (attempt < maxRetries) {\r\n\t\t\t\t\tconst wait = attempt === 0 ? 0 : 1000 * Math.pow(2, attempt - 1); // backoff_factor=1 -> 0s,1s,2s,4s...\r\n\t\t\t\t\tawait new Promise(r => this.adapter.setTimeout(r, wait, undefined));\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t\tthrow lastErr;\r\n\t\t\t}\r\n\t\t}\r\n\t\tthrow lastErr;\r\n\t}\r\n\r\n\tprivate raiseForStatus(resp: axios.AxiosResponse): void {\r\n\t\tif (resp.status >= 400 && resp.status < 600) {\r\n\t\t\tconst err = new Error(`${resp.status} ${resp.status >= 500 ? \"Server\" : \"Client\"} Error`) as Error & {\r\n\t\t\t\tstatus?: number;\r\n\t\t\t\tbody?: unknown;\r\n\t\t\t};\r\n\r\n\t\t\terr.status = resp.status;\r\n\t\t\terr.body = resp.data;\r\n\r\n\t\t\tthrow err;\r\n\t\t}\r\n\t}\r\n\r\n\tsendRebootRequest(): Promise<string> {\r\n\t\treturn this.makeRequest(\"<CSV><RESET></RESET></CSV>\");\r\n\t}\r\n\r\n\tsendStatusRequest(): Promise<string> {\r\n\t\treturn this.makeRequest(\"<CSV><CONNECT>ON</CONNECT></CSV>\");\r\n\t}\r\n\r\n\tsendEchonetEnable(): Promise<string> {\r\n\t\treturn this.makeRequest(\"<CSV><CONNECT>ON</CONNECT><ECHONET>ON</ECHONET></CSV>\");\r\n\t}\r\n\r\n\tsendCommand(command: Buffer | Uint8Array): Promise<string> {\r\n\t\tconst hex = Buffer.isBuffer(command) ? command.toString(\"hex\") : Buffer.from(command).toString(\"hex\");\r\n\t\treturn this.sendHexCommand(hex);\r\n\t}\r\n\r\n\tsendHexCommand(hexCommand: string): Promise<string> {\r\n\t\tconst payload = `<CSV><CONNECT>ON</CONNECT><CODE><VALUE>${hexCommand}</VALUE></CODE></CSV>`;\r\n\t\treturn this.makeRequest(payload);\r\n\t}\r\n\r\n\tclose(): void {\r\n\t\t// nothing to close; keep for API parity\r\n\t\t(this.http as any) = null;\r\n\t}\r\n}\r\n"],
  "mappings": "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",
  "names": ["axios"]
}
